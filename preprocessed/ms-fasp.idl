 import "ms-dtyp.idl";
 cpp_quote("#ifndef __FIREWALL_H_")
 cpp_quote("#define FW_CURRENT_BINARY_VERSION (FW_VERSION(2,31))")
 cpp_quote("#define FW_CURRENT_SCHEMA_VERSION (FW_VERSION(2,31))")
 typedef enum _tag_FW_STORE_TYPE
 {
     FW_STORE_TYPE_INVALID,
     FW_STORE_TYPE_GP_RSOP,
     FW_STORE_TYPE_LOCAL,
     FW_STORE_TYPE_NOT_USED_VALUE_3,
     FW_STORE_TYPE_NOT_USED_VALUE_4,
     FW_STORE_TYPE_DYNAMIC,
     FW_STORE_TYPE_GPO,
     FW_STORE_TYPE_DEFAULTS,
     FW_STORE_TYPE_NOT_USED_VALUE_8,
     FW_STORE_TYPE_NOT_USED_VALUE_9,
     FW_STORE_TYPE_NOT_USED_VALUE_10,
     FW_STORE_TYPE_NOT_USED_VALUE_11,
     FW_STORE_TYPE_MAX,
 } FW_STORE_TYPE;
 typedef enum _tag_FW_TRANSACTIONAL_STATE
 {
     FW_TRANSACTIONAL_STATE_NONE      = 0,
     FW_TRANSACTIONAL_STATE_NO_FLUSH,
     FW_TRANSACTIONAL_STATE_MAX
 } FW_TRANSACTIONAL_STATE;
 typedef
 [v1_enum]
 enum _tag_FW_PROFILE_TYPE
 {
     FW_PROFILE_TYPE_INVALID  = 0,
     FW_PROFILE_TYPE_DOMAIN   = 0x001,
     FW_PROFILE_TYPE_STANDARD = 0x002,
     FW_PROFILE_TYPE_PRIVATE  = FW_PROFILE_TYPE_STANDARD,
     FW_PROFILE_TYPE_PUBLIC   = 0x004,
     FW_PROFILE_TYPE_ALL      = 0x7FFFFFFF,
     FW_PROFILE_TYPE_CURRENT  = 0x80000000,
     FW_PROFILE_TYPE_NONE     = FW_PROFILE_TYPE_CURRENT + 1
 } FW_PROFILE_TYPE;
 typedef enum _tag_FW_POLICY_ACCESS_RIGHT
 {
     FW_POLICY_ACCESS_RIGHT_INVALID,
     FW_POLICY_ACCESS_RIGHT_READ,
     FW_POLICY_ACCESS_RIGHT_READ_WRITE,
     FW_POLICY_ACCESS_RIGHT_MAX
 }FW_POLICY_ACCESS_RIGHT;
 typedef enum _tag_FW_POLICY_STORE_FLAGS
 {
     FW_POLICY_STORE_FLAGS_NONE          = 0x0000,
     FW_POLICY_STORE_FLAGS_DELETE_DYNAMIC_RULES_AFTER_CLOSE  = 0x0001,
     FW_POLICY_STORE_FLAGS_OPEN_GP_CACHE = 0x0002,
     FW_POLICY_STORE_FLAGS_USE_GP_CACHE  = 0x0004,
     FW_POLICY_STORE_FLAGS_SAVE_GP_CACHE  = 0x0008,
     FW_POLICY_STORE_FLAGS_NOT_USED_VALUE_16 = 0x0010,
     FW_POLICY_STORE_FLAGS_MAX           = 0x0020
 }FW_POLICY_STORE_FLAGS;
 typedef struct _tag_FW_IPV4_SUBNET
 {
     DWORD      dwAddress;
     DWORD      dwSubNetMask;
 } FW_IPV4_SUBNET, *PFW_IPV4_SUBNET;
 typedef struct _tag_FW_IPV4_SUBNET_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV4_SUBNET    pSubNets;
 } FW_IPV4_SUBNET_LIST, *PFW_IPV4_SUBNET_LIST;
 typedef struct _tag_FW_IPV6_SUBNET
 {
     BYTE                Address[16];
     [range(0, 128)]
     DWORD               dwNumPrefixBits;
 } FW_IPV6_SUBNET, *PFW_IPV6_SUBNET;
 typedef struct _tag_FW_IPV6_SUBNET_LIST
 {
     [range(0, 10000)]
     DWORD               dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV6_SUBNET     pSubNets;
 } FW_IPV6_SUBNET_LIST, *PFW_IPV6_SUBNET_LIST;
 typedef struct _tag_FW_IPV4_ADDRESS_RANGE
 {
     DWORD      dwBegin;
     DWORD      dwEnd;
 } FW_IPV4_ADDRESS_RANGE, *PFW_IPV4_ADDRESS_RANGE;
 typedef struct _tag_FW_IPV6_ADDRESS_RANGE
 {
     BYTE     Begin[16];
     BYTE     End[16];
 } FW_IPV6_ADDRESS_RANGE, *PFW_IPV6_ADDRESS_RANGE;
 typedef struct _tag_FW_IPV4_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD                       dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV4_ADDRESS_RANGE      pRanges;
 } FW_IPV4_RANGE_LIST, *PFW_IPV4_RANGE_LIST;
 typedef struct _tag_FW_IPV6_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD                       dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV6_ADDRESS_RANGE      pRanges;
 } FW_IPV6_RANGE_LIST, *PFW_IPV6_RANGE_LIST;
 typedef struct _tag_FW_PORT_RANGE
 {
     WORD            wBegin;
     WORD            wEnd;
 } FW_PORT_RANGE, *PFW_PORT_RANGE;
 typedef struct _tag_FW_PORT_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_PORT_RANGE     pPorts;
 } FW_PORT_RANGE_LIST, *PFW_PORT_RANGE_LIST;
 typedef enum _tag_FW_PORT_KEYWORD
 {
     FW_PORT_KEYWORD_NONE              = 0x00,
     FW_PORT_KEYWORD_DYNAMIC_RPC_PORTS = 0x01,
     FW_PORT_KEYWORD_RPC_EP            = 0x02,
     FW_PORT_KEYWORD_TEREDO_PORT       = 0x04,
     FW_PORT_KEYWORD_IP_TLS_IN         = 0x08,
     FW_PORT_KEYWORD_IP_TLS_OUT        = 0x10,
     FW_PORT_KEYWORD_DHCP              = 0x20,
     FW_PORT_KEYWORD_PLAYTO_DISCOVERY  = 0x40,
     FW_PORT_KEYWORD_MDNS              = 0x80,
     FW_PORT_KEYWORD_CORTANA_OUT       = 0x100,
     FW_PORT_KEYWORD_PROXIMAL_TCP_CDP  = 0x200,
     FW_PORT_KEYWORD_MAX               = 0x400,
     FW_PORT_KEYWORD_MAX_V2_1          = 0x08,
     FW_PORT_KEYWORD_MAX_V2_10         = 0x20,
     FW_PORT_KEYWORD_MAX_V2_20         = 0x80,
     FW_PORT_KEYWORD_MAX_V2_24         = 0x100,
     FW_PORT_KEYWORD_MAX_V2_25         = 0x200
 }FW_PORT_KEYWORD;
 typedef struct _tag_FW_PORTS
 {
     WORD                wPortKeywords;
     FW_PORT_RANGE_LIST  Ports;
 }FW_PORTS,*PFW_PORTS;
 cpp_quote("#define FW_ICMP_CODE_ANY (256)")
 cpp_quote("#define FW_IP_PROTOCOL_ANY (256)")
 typedef struct _tag_FW_ICMP_TYPE_CODE
 {
     BYTE                bType;
     [range(0, 256)]
     WORD                wCode;
 } FW_ICMP_TYPE_CODE, *PFW_ICMP_TYPE_CODE;
 typedef struct _tag_FW_ICMP_TYPE_CODE_LIST
 {
     [range(0, 10000)]
     DWORD               dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_ICMP_TYPE_CODE  pEntries;
 } FW_ICMP_TYPE_CODE_LIST, *PFW_ICMP_TYPE_CODE_LIST;
 typedef struct _tag_FW_INTERFACE_LUIDS
 {
     [range(0, 10000)]
     DWORD       dwNumLUIDs;
     [size_is(dwNumLUIDs)]
     GUID*       pLUIDs;
 } FW_INTERFACE_LUIDS, *PFW_INTERFACE_LUIDS;
 typedef enum _tag_FW_DIRECTION
 {
     FW_DIR_INVALID = 0,
     FW_DIR_IN,
     FW_DIR_OUT,
     FW_DIR_MAX
 } FW_DIRECTION;
 typedef enum _tag_FW_INTERFACE_TYPE
 {
     FW_INTERFACE_TYPE_ALL            = 0x0000,
     FW_INTERFACE_TYPE_LAN            = 0x0001,
     FW_INTERFACE_TYPE_WIRELESS       = 0x0002,
     FW_INTERFACE_TYPE_REMOTE_ACCESS  = 0x0004,
     FW_INTERFACE_TYPE_MOBILE_BBAND   = 0x0008,
     FW_INTERFACE_TYPE_MAX            = 0x0010,
     FW_INTERFACE_TYPE_MAX_V2_23      = 0x0008,
 } FW_INTERFACE_TYPE;
 typedef enum _tag_FW_ADDRESS_KEYWORD
 {
     FW_ADDRESS_KEYWORD_NONE            = 0x0000,
     FW_ADDRESS_KEYWORD_LOCAL_SUBNET    = 0x0001,
     FW_ADDRESS_KEYWORD_DNS             = 0x0002,
     FW_ADDRESS_KEYWORD_DHCP            = 0x0004,
     FW_ADDRESS_KEYWORD_WINS            = 0x0008,
     FW_ADDRESS_KEYWORD_DEFAULT_GATEWAY = 0x0010,
     FW_ADDRESS_KEYWORD_INTRANET        = 0x0020,
     FW_ADDRESS_KEYWORD_INTERNET        = 0x0040,
     FW_ADDRESS_KEYWORD_PLAYTO_RENDERERS= 0x0080,
     FW_ADDRESS_KEYWORD_REMOTE_INTRANET = 0x0100,
     FW_ADDRESS_KEYWORD_CAPTIVE_PORTAL  = 0x0200,
     FW_ADDRESS_KEYWORD_MAX             = 0x0400,
     FW_ADDRESS_KEYWORD_MAX_V2_10       = 0x0020,
     FW_ADDRESS_KEYWORD_MAX_V2_29       = 0x0200,
 }FW_ADDRESS_KEYWORD;
 typedef struct _tag_FW_ADDRESSES
 {
     DWORD                dwV4AddressKeywords;
     DWORD                dwV6AddressKeywords;
     FW_IPV4_SUBNET_LIST  V4SubNets;
     FW_IPV4_RANGE_LIST   V4Ranges;
     FW_IPV6_SUBNET_LIST  V6SubNets;
     FW_IPV6_RANGE_LIST   V6Ranges;
 }FW_ADDRESSES, *PFW_ADDRESSES;
 typedef enum _tag_FW_TRUST_TUPLE_KEYWORD
 {
     FW_TRUST_TUPLE_KEYWORD_NONE                = 0x0000,
     FW_TRUST_TUPLE_KEYWORD_PROXIMITY           = 0x0001,
     FW_TRUST_TUPLE_KEYWORD_PROXIMITY_SHARING   = 0x0002,
     FW_TRUST_TUPLE_KEYWORD_WFD_PRINT           = 0x0004,
     FW_TRUST_TUPLE_KEYWORD_WFD_DISPLAY         = 0x0008,
     FW_TRUST_TUPLE_KEYWORD_WFD_DEVICES         = 0x0010,
     FW_TRUST_TUPLE_KEYWORD_WFD_KM_DRIVER       = 0x0020,
     FW_TRUST_TUPLE_KEYWORD_UPNP                = 0x0040,
     FW_TRUST_TUPLE_KEYWORD_WFD_CDP             = 0x0080,
     FW_TRUST_TUPLE_KEYWORD_MAX                 = 0x0100,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_20           = 0x0004,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_26           = 0x0020,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_27           = 0x0080
 }FW_TRUST_TUPLE_KEYWORD;
 typedef
 [v1_enum]
 enum _tag_FW_RULE_STATUS
 {
     FW_RULE_STATUS_OK = 0x00010000,
     FW_RULE_STATUS_PARTIALLY_IGNORED = 0x00020000,
     FW_RULE_STATUS_IGNORED = 0x00040000,
     FW_RULE_STATUS_PARSING_ERROR = 0x00080000,
     FW_RULE_STATUS_PARSING_ERROR_NAME = 0x00080001,
     FW_RULE_STATUS_PARSING_ERROR_DESC = 0x00080002,
     FW_RULE_STATUS_PARSING_ERROR_APP = 0x00080003,
     FW_RULE_STATUS_PARSING_ERROR_SVC = 0x00080004,
     FW_RULE_STATUS_PARSING_ERROR_RMA = 0x00080005,
     FW_RULE_STATUS_PARSING_ERROR_RUA = 0x00080006,
     FW_RULE_STATUS_PARSING_ERROR_EMBD = 0x00080007,
     FW_RULE_STATUS_PARSING_ERROR_RULE_ID = 0x00080008,
     FW_RULE_STATUS_PARSING_ERROR_PHASE1_AUTH = 0x00080009,
     FW_RULE_STATUS_PARSING_ERROR_PHASE2_CRYPTO = 0x0008000A,
     FW_RULE_STATUS_PARSING_ERROR_PHASE2_AUTH = 0x0008000B,
     FW_RULE_STATUS_PARSING_ERROR_RESOLVE_APP = 0x0008000C,
     FW_RULE_STATUS_PARSING_ERROR_MAINMODE_ID = 0x0008000D,
     FW_RULE_STATUS_PARSING_ERROR_PHASE1_CRYPTO = 0x0008000E,
     FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINTS = 0x0008000F,
     FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINT_FQDN = 0x00080010,
     FW_RULE_STATUS_PARSING_ERROR_KEY_MODULE = 0x00080011,
     FW_RULE_STATUS_PARSING_ERROR_LUA = 0x00080012,
     FW_RULE_STATUS_PARSING_ERROR_FWD_LIFETIME = 0x00080013,
     FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_MACHINE_AUTHZ_SDDL = 0x00080014,
     FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_USER_AUTHZ_SDDL = 0x00080015,
     FW_RULE_STATUS_PARSING_ERROR_NETNAMES_STRING = 0x00080016,
     FW_RULE_STATUS_PARSING_ERROR_SECURITY_REALM_ID_STRING = 0x00080017,
     FW_RULE_STATUS_PARSING_ERROR_FQBN_STRING = 0x00080018,
     FW_RULE_STATUS_SEMANTIC_ERROR = 0x00100000,
     FW_RULE_STATUS_SEMANTIC_ERROR_RULE_ID = 0x00100010,
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTS = 0x00100020,
     FW_RULE_STATUS_SEMANTIC_ERROR_PORT_KEYW = 0x00100021,
     FW_RULE_STATUS_SEMANTIC_ERROR_PORT_RANGE = 0x00100022,
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTRANGE_RESTRICTION = 0x00100023,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_SUBNETS = 0x00100040,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_SUBNETS = 0x00100041,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_RANGES = 0x00100042,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_RANGES = 0x00100043,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_RANGE = 0x00100044,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_MASK = 0x00100045,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_PREFIX = 0x00100046,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYW = 0x00100047,
     FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_PROP = 0x00100048,
     FW_RULE_STATUS_SEMANTIC_ERROR_RADDR_PROP = 0x00100049,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6 = 0x0010004A,
     FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_INTF = 0x0010004B,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4 = 0x0010004C,
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_ENDPOINT_ADDR = 0x0010004D,
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_VER  = 0x0010004E,
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_MISMATCH_ADDR  = 0x0010004F,
     FW_RULE_STATUS_SEMANTIC_ERROR_PROFILE = 0x00100050,
     FW_RULE_STATUS_SEMANTIC_ERROR_ICMP = 0x00100060,
     FW_RULE_STATUS_SEMANTIC_ERROR_ICMP_CODE = 0x00100061,
     FW_RULE_STATUS_SEMANTIC_ERROR_IF_ID = 0x00100070,
     FW_RULE_STATUS_SEMANTIC_ERROR_IF_TYPE = 0x00100071,
     FW_RULE_STATUS_SEMANTIC_ERROR_ACTION = 0x00100080,
     FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS = 0x00100081,
     FW_RULE_STATUS_SEMANTIC_ERROR_DO_NOT_SECURE = 0x00100082,
     FW_RULE_STATUS_SEMANTIC_ERROR_ACTION_BLOCK_IS_ENCRYPTED_SECURE = 0x00100083,
     FW_RULE_STATUS_SEMANTIC_ERROR_INCOMPATIBLE_FLAG_OR_ACTION_WITH_SECURITY_REALM = 0x00100084,
     FW_RULE_STATUS_SEMANTIC_ERROR_DIR = 0x00100090,
     FW_RULE_STATUS_SEMANTIC_ERROR_PROT = 0x001000A0,
     FW_RULE_STATUS_SEMANTIC_ERROR_PROT_PROP = 0x001000A1,
     FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_EDGE_PROP = 0x001000A2,
     FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS_OUTBOUND = 0x001000A3,
     FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_USER_INVALID_RULE = 0x001000A4,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS = 0x001000B0,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_AUTH = 0x001000B1,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_BLOCK = 0x001000B2,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_DYN_RPC = 0x001000B3,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_ENCRYPT = 0x001000B4,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_VER = 0x001000B5,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE = 0x001000B6,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP_VER = 0x001000B7,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP = 0x001000B8,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES_VER = 0x001000B9,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES = 0x001000BA,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_IP_HTTPS_VER = 0x001000BB,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_IP_TLS_VER = 0x001000BB,
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTRANGE_VER = 0x001000BC,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ADDRS_TRAVERSE_DEFER_VER = 0x001000BD,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_OUTBOUND = 0x001000BE,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_WITH_OUTBOUND_BYPASS_VER = 0x001000BF,
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_AUTH_LIST = 0x001000C0,
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_USER_LIST = 0x001000C1,
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_LIST = 0x001000C2,
     FW_RULE_STATUS_SEMANTIC_ERROR_LUA_VER = 0x001000C3,
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER = 0x001000C4,
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER_VER = 0x001000C5,
     FW_RULE_STATUS_SEMANTIC_ERROR_LUA_CONDITIONAL_VER = 0x001000C6,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SYSTEMOS_GAMEOS = 0x001000C7,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_CORTANA_VER = 0x001000C8,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_REMOTENAME = 0x001000C9,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ALLOW_PROFILE_CROSSING_VER = 0x001000D0,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_LOCAL_ONLY_MAPPED_VER = 0x001000D1,
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM = 0x001000E0,
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP_VER = 0x001000E1,
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP = 0x001000E2,
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_NOANY_ADDR = 0x001000F0,
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_EXEMPT_WITH_GATEWAY = 0x001000F1,
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_EXEMPT_VER = 0x001000F2,
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYWORD_VER = 0x001000F3,
     FW_RULE_STATUS_SEMANTIC_ERROR_KEY_MODULE_VER = 0x001000F4,
     FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID = 0x00100100,
     FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID_VER = 0x00100101,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INCOMPATIBLE = 0x00100200,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INVALID = 0x00100201,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_VER = 0x00100202,
     FW_RULE_STATUS_SEMANTIC_ERROR_INTERFACE_TYPES_VER = 0x00100301,
     FW_RULE_STATUS_SEMANTIC_ERROR_NETNAMES_VER = 0x00100401,
     FW_RULE_STATUS_SEMANTIC_ERROR_SECURITY_REALM_ID_VER = 0x00100402,
     FW_RULE_STATUS_SEMANTIC_ERROR_SYSTEMOS_GAMEOS_VER = 0x00100403,
     FW_RULE_STATUS_SEMANTIC_ERROR_DEVMODE_VER = 0x00100404,
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_SERVERNAME_VER = 0x00100405,
     FW_RULE_STATUS_SEMANTIC_ERROR_FQBN_VER = 0x00100406,
     FW_RULE_STATUS_SEMANTIC_ERROR_COMPARTMENT_ID_VER = 0x00100407,
     FW_RULE_STATUS_SEMANTIC_ERROR_CALLOUT_AND_AUDIT_VER = 0x00100408,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_SET_ID = 0x00100500,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_SET_ID = 0x00100510,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_SET_ID = 0x00100511,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_DICTATE_VER = 0x00100512,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_NOTIFY_VER = 0x00100513,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_VER = 0x00100514,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_VER = 0x00100515,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_ON_TUNNEL = 0x00100516,
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_ON_TUNNEL = 0x00100517,
     FW_RULE_STATUS_SEMANTIC_ERROR_PER_RULE_AND_GLOBAL_AUTHZ = 0x00100518,
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SECURITY_REALM = 0x00100519,
     FW_RULE_STATUS_SEMANTIC_ERROR_SET_ID = 0x00101000,
     FW_RULE_STATUS_SEMANTIC_ERROR_IPSEC_PHASE = 0x00101010,
     FW_RULE_STATUS_SEMANTIC_ERROR_EMPTY_SUITES = 0x00101020,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_METHOD = 0x00101030,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_AUTH_METHOD = 0x00101031,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_ANONYMOUS = 0x00101032,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_DUPLICATE = 0x00101033,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_VER = 0x00101034,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SUITE_FLAGS = 0x00101040,
     FW_RULE_STATUS_SEMANTIC_ERROR_HEALTH_CERT = 0x00101041,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SIGNCERT_VER = 0x00101042,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_INTERMEDIATE_CA_VER = 0x00101043,
     FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_SHKEY = 0x00101050,
     FW_RULE_STATUS_SEMANTIC_ERROR_CA_NAME = 0x00101060,
     FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CERTS = 0x00101061,
     FW_RULE_STATUS_SEMANTIC_ERROR_NON_CONTIGUOUS_CERTS = 0x00101062,
     FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CA_TYPE_IN_BLOCK = 0x00101063,
     FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_USER_AUTH = 0x00101070,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER = 0x00101071,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER_MISMATCH = 0x00101072,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_RENEWAL_HASH = 0x00101073,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_HASH = 0x00101074,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_EKU = 0x00101075,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME_TYPE = 0x00101076,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME = 0x00101077,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_CRITERIA_TYPE = 0x00101078,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_MISSING_CRITERIA = 0x00101079,
     FW_RULE_STATUS_SEMANTIC_ERROR_PROXY_SERVER = 0x00101080,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_PROXY_SERVER_VER = 0x00101081,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_NON_DEFAULT_ID = 0x00105000,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_FLAGS = 0x00105001,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_MINUTES = 0x00105002,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_SESSIONS = 0x00105003,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCHANGE = 0x00105004,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION = 0x00105005,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH = 0x00105006,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION_VER = 0x00105007,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH_VER = 0x00105008,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCH_VER = 0x00105009,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS = 0x00105020,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PROTOCOL = 0x00105021,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION = 0x00105022,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH = 0x00105023,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_MINUTES = 0x00105024,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_KBYTES = 0x00105025,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION_VER = 0x00105026,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH_VER = 0x00105027,
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS_VER = 0x00105028,
     FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH = 0x00105040,
     FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH_COMPAT = 0x00105041,
     FW_RULE_STATUS_SEMANTIC_ERROR_SCHEMA_VERSION = 0x00105050,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_OR_AND_CONDITIONS = 0x00106000,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_AND_CONDITIONS = 0x00106001,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY = 0x00106002,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_MATCH_TYPE = 0x00106003,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_DATA_TYPE = 0x00106004,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY_AND_DATA_TYPE = 0x00106005,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEYS_PROTOCOL_PORT = 0x00106006,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROFILE = 0x00106007,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_STATUS = 0x00106008,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_FILTERID = 0x00106009,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_APP_PATH = 0x00106010,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROTOCOL = 0x00106011,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_LOCAL_PORT = 0x00106012,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_REMOTE_PORT = 0x00106013,
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_SVC_NAME = 0x00106015,
     FW_RULE_STATUS_SEMANTIC_ERROR_REQUIRE_IN_CLEAR_OUT_ON_TRANSPORT = 0x00107000,
     FW_RULE_STATUS_SEMANTIC_ERROR_BYPASS_TUNNEL_IF_SECURE_ON_TRANSPORT = 0x00107001,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00107002,
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_PSK = 0x00107003,
     FW_RULE_STATUS_RUNTIME_ERROR = 0x00200000,
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_AUTH_NOT_FOUND = 0x00200001,
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_AUTH_NOT_FOUND = 0x00200002,
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_CRYPTO_NOT_FOUND = 0x00200003,
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_MCHN_SHKEY_MISMATCH = 0x00200004,
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_CRYPTO_NOT_FOUND = 0x00200005,
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00200006,
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_PSK = 0x00200007,
     FW_RULE_STATUS_RUNTIME_ERROR_KEY_MODULE_AUTH_MISMATCH = 0x00200008,
     FW_RULE_STATUS_ERROR  = FW_RULE_STATUS_PARSING_ERROR |FW_RULE_STATUS_SEMANTIC_ERROR
     |FW_RULE_STATUS_RUNTIME_ERROR,
     FW_RULE_STATUS_ALL = 0xFFFF0000
 } FW_RULE_STATUS;
 typedef enum _tag_FW_RULE_STATUS_CLASS
 {
     FW_RULE_STATUS_CLASS_OK                 = FW_RULE_STATUS_OK,
     FW_RULE_STATUS_CLASS_PARTIALLY_IGNORED  = FW_RULE_STATUS_PARTIALLY_IGNORED,
     FW_RULE_STATUS_CLASS_IGNORED            = FW_RULE_STATUS_IGNORED,
     FW_RULE_STATUS_CLASS_PARSING_ERROR      = FW_RULE_STATUS_PARSING_ERROR,
     FW_RULE_STATUS_CLASS_SEMANTIC_ERROR     = FW_RULE_STATUS_SEMANTIC_ERROR,
     FW_RULE_STATUS_CLASS_RUNTIME_ERROR      = FW_RULE_STATUS_RUNTIME_ERROR,
     FW_RULE_STATUS_CLASS_ERROR              = FW_RULE_STATUS_ERROR,
     FW_RULE_STATUS_CLASS_ALL                = FW_RULE_STATUS_ALL
 } FW_RULE_STATUS_CLASS;
 typedef enum _tag_FW_OBJECT_CTRL_FLAG
 {
     FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA     = 0x0001,
 } FW_OBJECT_CTRL_FLAG;
 typedef enum _tag_FW_ENFORCEMENT_STATE
 {
     FW_ENFORCEMENT_STATE_INVALID,
     FW_ENFORCEMENT_STATE_FULL,
     FW_ENFORCEMENT_STATE_WF_OFF_IN_PROFILE,
     FW_ENFORCEMENT_STATE_CATEGORY_OFF,
     FW_ENFORCEMENT_STATE_DISABLED_OBJECT,
     FW_ENFORCEMENT_STATE_INACTIVE_PROFILE,
     FW_ENFORCEMENT_STATE_LOCAL_ADDRESS_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_ADDRESS_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_LOCAL_PORT_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_PORT_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_INTERFACE_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_APPLICATION_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_MACHINE_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_USER_EMPTY,
     FW_ENFORCEMENT_STATE_LOCAL_GLOBAL_OPEN_PORTS_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_AUTHORIZED_APPLICATIONS_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_FIREWALL_RULES_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_CONSEC_RULES_DISALLOWED,
     FW_ENFORCEMENT_STATE_MISMATCHED_PLATFORM,
     FW_ENFORCEMENT_STATE_OPTIMIZED_OUT,
     FW_ENFORCEMENT_STATE_LOCAL_USER_EMPTY,
     FW_ENFORCEMENT_STATE_TRANSPORT_MACHINE_SD_EMPTY,
     FW_ENFORCEMENT_STATE_TRANSPORT_USER_SD_EMPTY,
     FW_ENFORCEMENT_STATE_TUPLE_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_NETNAME_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_MAX
 } FW_ENFORCEMENT_STATE;
 typedef struct _tag_FW_OBJECT_METADATA
 {
     UINT64 qwFilterContextID;
     [range(0, 100)]
     DWORD dwNumEntries;
     [size_is(dwNumEntries)]
     FW_ENFORCEMENT_STATE *pEnforcementStates;
 } FW_OBJECT_METADATA, *PFW_OBJECT_METADATA;
 typedef enum _tag_FW_OS_PLATFORM_OP
 {
     FW_OS_PLATFORM_OP_EQ,
     FW_OS_PLATFORM_OP_GTEQ,
     FW_OS_PLATFORM_OP_MAX,
     FW_OS_PLATFORM_OP_FIELD_SIZE = 5,
     FW_OS_PLATFORM_OP_FIELD_MASK = 0xF8
 } FW_OS_PLATFORM_OP;
 typedef struct _tag_FW_OS_PLATFORM
 {
     BYTE    bPlatform;
     BYTE    bMajorVersion;
     BYTE    bMinorVersion;
     BYTE    Reserved;
 }FW_OS_PLATFORM, *PFW_OS_PLATFORM;
 typedef struct _tag_FW_OS_PLATFORM_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_OS_PLATFORM    pPlatforms;
 }FW_OS_PLATFORM_LIST, *PFW_OS_PLATFORM_LIST;
 typedef struct _tag_FW_NETWORK_NAMES
 {
     DWORD dwNumEntries;
     [string, unique, size_is(dwNumEntries,)]
     LPWSTR *wszNames;
 } FW_NETWORK_NAMES, *PFW_NETWORK_NAMES;
 typedef enum _tag_FW_RULE_ORIGIN_TYPE
 {
     FW_RULE_ORIGIN_INVALID,
     FW_RULE_ORIGIN_LOCAL,
     FW_RULE_ORIGIN_GP,
     FW_RULE_ORIGIN_DYNAMIC,
     FW_RULE_ORIGIN_AUTOGEN,
     FW_RULE_ORIGIN_HARDCODED,
     FW_RULE_ORIGIN_MAX
 }FW_RULE_ORIGIN_TYPE;
 typedef enum _tag_FW_ENUM_RULES_FLAGS
 {
     FW_ENUM_RULES_FLAG_NONE                 = 0x0000,
     FW_ENUM_RULES_FLAG_RESOLVE_NAME         = 0x0001,
     FW_ENUM_RULES_FLAG_RESOLVE_DESCRIPTION  = 0x0002,
     FW_ENUM_RULES_FLAG_RESOLVE_APPLICATION  = 0x0004,
     FW_ENUM_RULES_FLAG_RESOLVE_KEYWORD      = 0x0008,
     FW_ENUM_RULES_FLAG_RESOLVE_GPO_NAME     = 0x0010,
     FW_ENUM_RULES_FLAG_EFFECTIVE            = 0x0020,
     FW_ENUM_RULES_FLAG_INCLUDE_METADATA     = 0x0040,
     FW_ENUM_RULES_FLAG_MAX                  = 0x0080
 }FW_ENUM_RULES_FLAGS;
 typedef enum _tag_FW_RULE_ACTION
 {
     FW_RULE_ACTION_INVALID = 0,
     FW_RULE_ACTION_ALLOW_BYPASS,
     FW_RULE_ACTION_BLOCK,
     FW_RULE_ACTION_ALLOW,
     FW_RULE_ACTION_MAX
 } FW_RULE_ACTION;
 typedef enum _tag_FW_RULE_FLAGS
 {
     FW_RULE_FLAGS_NONE              = 0x0000,
     FW_RULE_FLAGS_ACTIVE            = 0x0001,
     FW_RULE_FLAGS_AUTHENTICATE      = 0x0002,
     FW_RULE_FLAGS_AUTHENTICATE_WITH_ENCRYPTION = 0x0004,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE = 0x0008,
     FW_RULE_FLAGS_LOOSE_SOURCE_MAPPED = 0x00010,
     FW_RULE_FLAGS_MAX_V2_1          = 0x0020,
     FW_RULE_FLAGS_AUTH_WITH_NO_ENCAPSULATION = 0x0020,
     FW_RULE_FLAGS_MAX_V2_9          = 0x0040,
     FW_RULE_FLAGS_AUTH_WITH_ENC_NEGOTIATE = 0x0040,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE_DEFER_APP = 0x0080,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE_DEFER_USER = 0x0100,
     FW_RULE_FLAGS_AUTHENTICATE_BYPASS_OUTBOUND = 0x0200,
     FW_RULE_FLAGS_MAX_V2_10         = 0x0400,
     FW_RULE_FLAGS_ALLOW_PROFILE_CROSSING = 0x0400,
     FW_RULE_FLAGS_LOCAL_ONLY_MAPPED = 0x0800,
     FW_RULE_FLAGS_MAX_V2_20         = 0x1000,
     FW_RULE_FLAGS_LUA_CONDITIONAL_ACE = 0x1000,
     FW_RULE_FLAGS_BIND_TO_INTERFACE = 0x2000,
     FW_RULE_FLAGS_MAX               = 0x4000,
 }FW_RULE_FLAGS;
 typedef enum _tag_FW_RULE_FLAGS2
 {
     FW_RULE_FLAGS2_NONE                = 0x0000,
     FW_RULE_FLAGS2_SYSTEMOS_ONLY       = 0x0001,
     FW_RULE_FLAGS2_GAMEOS_ONLY         = 0x0002,
     FW_RULE_FLAGS2_DEVMODE             = 0x0004,
     FW_RULE_FLAGS_MAX_V2_26            = 0x0008,
     FW_RULE_FLAGS2_NOT_USED_VALUE_8    = 0x0008,
     FW_RULE_FLAGS2_NOT_USED_VALUE_16   = 0x0010,
     FW_RULE_FLAGS2_NOT_USED_VALUE_32   = 0x0020,
     FW_RULE_FLAGS2_NOT_USED_VALUE_64   = 0x0040,
     FW_RULE_FLAGS2_CALLOUT_AND_AUDIT   = 0x0080,
     FW_RULE_FLAGS2_NOT_USED_VALUE_256  = 0x0100,
     FW_RULE_FLAGS2_NOT_USED_VALUE_512  = 0x0200,
     FW_RULE_FLAGS2_NOT_USED_VALUE_1024 = 0x0400,
     FW_RULE_FLAGS2_MAX                 = 0x0800
 }FW_RULE_FLAGS2;
 typedef struct _tag_FW_RULE2_0
 {
     struct _tag_FW_RULE2_0 *pNext;
     WORD         wSchemaVersion;
     [string, range(1,10001), ref]
     WCHAR*       wszRuleId;
     [string, range(1,10001)]
     WCHAR*       wszName;
     [string, range(1,10001)]
     WCHAR*       wszDescription;
     DWORD        dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION Direction;
     [range(0,256)]
     WORD         wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
             FW_PORTS LocalPorts;
             FW_PORTS RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST  V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST  V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     WCHAR*              wszLocalApplication;
     [string, range(1,10001)]
     WCHAR*              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     WCHAR*              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     WCHAR*              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR*           wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS   Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*           wszGPOName;
     DWORD            Reserved;
 } FW_RULE2_0, *PFW_RULE2_0;
 typedef struct _tag_FW_RULE2_10
 {
     struct _tag_FW_RULE2_10 *pNext;
     WORD          wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR        wszRuleId;
     [string, range(1,10001)]
     LPWSTR        wszName;
     [string, range(1,10001)]
     LPWSTR        wszDescription;
     DWORD         dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION  Direction;
     [range(0,256)]
     WORD          wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST    V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST    V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
 } FW_RULE2_10, *PFW_RULE2_10;
 typedef struct _tag_FW_RULE2_20
 {
     struct _tag_FW_RULE2_20 *pNext;
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR *             wszPackageId;
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;
     DWORD               dwTrustTupleKeywords;
 } FW_RULE2_20, *PFW_RULE2_20;
 typedef struct _tag_FW_RULE2_24
 {
     struct _tag_FW_RULE2_24 *pNext;
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,10001)]
     WCHAR*             wszLocalUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR *            wszPackageId;
     [string, range(1,10001)]
     WCHAR *            wszLocalUserOwner;
     DWORD              dwTrustTupleKeywords;
     FW_NETWORK_NAMES   OnNetworkNames;
     [string, range(1,10001)]
     WCHAR*             wszSecurityRealmId;
 } FW_RULE2_24, *PFW_RULE2_24;
 typedef struct _tag_FW_RULE2_25
 {
     struct _tag_FW_RULE2_25 *pNext;
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR *             wszPackageId;
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;
     DWORD               dwTrustTupleKeywords;
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
     WCHAR*              wszSecurityRealmId;
     WORD                wFlags2;
 } FW_RULE2_25, *PFW_RULE2_25;
 typedef struct _tag_FW_RULE2_26
 {
     struct _tag_FW_RULE2_26 *pNext;
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
     FW_PORTS        LocalPorts;
         FW_PORTS       RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST      V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST      V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR *             wszPackageId;
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;
     DWORD               dwTrustTupleKeywords;
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
     WCHAR*              wszSecurityRealmId;
     WORD                wFlags2;
     FW_NETWORK_NAMES    RemoteOutServerNames;
 } FW_RULE2_26, *PFW_RULE2_26;
 typedef struct _tag_FW_RULE2_27
 {
    struct _tag_FW_RULE2_27 *pNext;
    unsigned short                  wSchemaVersion;
    [string, range(1, 512), ref]    wchar_t* wszRuleId;
    [string, range(1, 10001)]       wchar_t* wszName;
    [string, range(1, 10001)]       wchar_t* wszDescription;  unsigned long dwProfiles;
    [range(FW_DIR_INVALID, FW_DIR_OUT)]
    FW_DIRECTION Direction;
    [range(0, 256)] unsigned short  wIpProtocol;
    [switch_type(unsigned short), switch_is(wIpProtocol)]
      union {  [case(6,17)] struct {
        FW_PORTS                    LocalPorts;
        FW_PORTS                    RemotePorts;
        };
        [case(1)]
        FW_ICMP_TYPE_CODE_LIST      V4TypeCodeList;
        [case(58)]
        FW_ICMP_TYPE_CODE_LIST      V6TypeCodeList;
        [default];
      };
    FW_ADDRESSES                    LocalAddresses;
    FW_ADDRESSES                    RemoteAddresses;
    FW_INTERFACE_LUIDS              LocalInterfaceIds;
      unsigned long                 dwLocalInterfaceTypes;
 [string, range(1, 10001)] wchar_t* wszLocalApplication;
 [string, range(1, 10001)] wchar_t* wszLocalService;
      [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
    FW_RULE_ACTION                  Action;
      unsigned short                wFlags;
 [string, range(1, 10001)] wchar_t* wszRemoteMachineAuthorizationList;
 [string, range(1, 10001)] wchar_t* wszRemoteUserAuthorizationList;
 [string, range(1, 10001)] wchar_t* wszEmbeddedContext;
    FW_OS_PLATFORM_LIST             PlatformValidityList;
    FW_RULE_STATUS                  Status;
    [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
    FW_RULE_ORIGIN_TYPE Origin;
 [string, range(1, 10001)] wchar_t* wszGPOName;
 unsigned long Reserved;
      [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
    PFW_OBJECT_METADATA             pMetaData;
   [string, range(1, 10001)] WCHAR* wszLocalUserAuthorizationList;
   [string, range(1, 10001)] WCHAR* wszPackageId;
  [string, range(1, 10001)] WCHAR*  wszLocalUserOwner;
      unsigned long                 dwTrustTupleKeywords;
    FW_NETWORK_NAMES                OnNetworkNames;
      [string, range(1, 10001)] WCHAR* wszSecurityRealmId;
      unsigned short                wFlags2;
    FW_NETWORK_NAMES                RemoteOutServerNames;
    [string, range(1,10001)] WCHAR* wszFqbn;
    unsigned long                   compartmentId;
 }FW_RULE2_27,
 *PFW_RULE2_27;
 typedef struct _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST
 {
 DWORD dwNumIds;
 [size_is(dwNumIds)] UINT32* ids;
 }
 FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST,
 *PFW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST;
 typedef struct _tag_FW_RULE
 {
     struct _tag_FW_RULE *pNext;
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol;
     [switch_type(WORD), switch_is(wIpProtocol)]
     union
     {
         [case(6,17)]
         struct
         {
             FW_PORTS            LocalPorts;
             FW_PORTS            RemotePorts;
         };
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST  V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST  V6TypeCodeList;
         [default]
         ;
     };
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     FW_RULE_STATUS      Status;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     LPWSTR              wszGPOName;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;
     [string, range(1,10001)]
     WCHAR *             wszPackageId;
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;
     DWORD               dwTrustTupleKeywords;
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
     WCHAR* wszSecurityRealmId;
     WORD   wFlags2;
    FW_NETWORK_NAMES    RemoteOutServerNames;
    [string, range(1,10001)]
    WCHAR* wszFqbn;
    DWORD compartmentId;
     GUID  providerContextKey;
     FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST  RemoteDynamicKeywordAddresses;
}  FW_RULE, *PFW_RULE;
 typedef enum _tag_FW_PROFILE_CONFIG
 {
     FW_PROFILE_CONFIG_INVALID,
     FW_PROFILE_CONFIG_ENABLE_FW,
     FW_PROFILE_CONFIG_DISABLE_STEALTH_MODE,
     FW_PROFILE_CONFIG_SHIELDED,
     FW_PROFILE_CONFIG_DISABLE_UNICAST_RESPONSES_TO_MULTICAST_BROADCAST,
     FW_PROFILE_CONFIG_LOG_DROPPED_PACKETS,
     FW_PROFILE_CONFIG_LOG_SUCCESS_CONNECTIONS,
     FW_PROFILE_CONFIG_LOG_IGNORED_RULES,
     FW_PROFILE_CONFIG_LOG_MAX_FILE_SIZE,
     FW_PROFILE_CONFIG_LOG_FILE_PATH,
     FW_PROFILE_CONFIG_DISABLE_INBOUND_NOTIFICATIONS,
     FW_PROFILE_CONFIG_AUTH_APPS_ALLOW_USER_PREF_MERGE,
     FW_PROFILE_CONFIG_GLOBAL_PORTS_ALLOW_USER_PREF_MERGE,
     FW_PROFILE_CONFIG_ALLOW_LOCAL_POLICY_MERGE,
     FW_PROFILE_CONFIG_ALLOW_LOCAL_IPSEC_POLICY_MERGE,
     FW_PROFILE_CONFIG_DISABLED_INTERFACES,
     FW_PROFILE_CONFIG_DEFAULT_OUTBOUND_ACTION,
     FW_PROFILE_CONFIG_DEFAULT_INBOUND_ACTION,
     FW_PROFILE_CONFIG_DISABLE_STEALTH_MODE_IPSEC_SECURED_PACKET_EXEMPTION,
     FW_PROFILE_CONFIG_MAX
 } FW_PROFILE_CONFIG;
 typedef enum _FW_GLOBAL_CONFIG_IPSEC_EXEMPT_VALUES
 {
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_NONE               =  0x0000,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_NEIGHBOR_DISC      =  0x0001,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_ICMP               =  0x0002,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_ROUTER_DISC        =  0x0004,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_NEIGHBOR_DISC_RFC  =
         FW_GLOBAL_CONFIG_IPSEC_EXEMPT_NEIGHBOR_DISC | FW_GLOBAL_CONFIG_IPSEC_EXEMPT_ROUTER_DISC,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_DHCP               =  0x0008,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT_MAX                =  0x0010
 }FW_GLOBAL_CONFIG_IPSEC_EXEMPT_VALUES;
 typedef enum _FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING_VALUES
 {
     FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING_NONE       = 0,
     FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING_UTF_8,
     FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING_MAX
 } FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING_VALUES;
 typedef enum _FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_VALUES
 {
     FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_NEVER                        = 0,
     FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_SERVER_BEHIND_NAT,
     FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_SERVER_AND_CLIENT_BEHIND_NAT,
     FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_MAX
 } FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT_VALUES;
 typedef enum _FW_GLOBAL_CONFIG_ENABLE_PACKET_QUEUE_FLAGS
 {
   FW_GLOBAL_CONFIG_PACKET_QUEUE_NONE,
   FW_GLOBAL_CONFIG_PACKET_QUEUE_INBOUND,
   FW_GLOBAL_CONFIG_PACKET_QUEUE_FORWARD,
   FW_GLOBAL_CONFIG_PACKET_QUEUE_MAX
 } FW_GLOBAL_CONFIG_ENABLE_PACKET_QUEUE_FLAGS;
 typedef enum _tag_FW_GLOBAL_CONFIG
 {
     FW_GLOBAL_CONFIG_INVALID,
     FW_GLOBAL_CONFIG_POLICY_VERSION_SUPPORTED,
     FW_GLOBAL_CONFIG_CURRENT_PROFILE,
     FW_GLOBAL_CONFIG_DISABLE_STATEFUL_FTP,
     FW_GLOBAL_CONFIG_DISABLE_STATEFUL_PPTP,
     FW_GLOBAL_CONFIG_SA_IDLE_TIME,
     FW_GLOBAL_CONFIG_PRESHARED_KEY_ENCODING,
     FW_GLOBAL_CONFIG_IPSEC_EXEMPT,
     FW_GLOBAL_CONFIG_CRL_CHECK,
     FW_GLOBAL_CONFIG_IPSEC_THROUGH_NAT,
     FW_GLOBAL_CONFIG_POLICY_VERSION,
     FW_GLOBAL_CONFIG_BINARY_VERSION_SUPPORTED,
     FW_GLOBAL_CONFIG_IPSEC_TUNNEL_REMOTE_MACHINE_AUTHORIZATION_LIST,
     FW_GLOBAL_CONFIG_IPSEC_TUNNEL_REMOTE_USER_AUTHORIZATION_LIST,
     FW_GLOBAL_CONFIG_OPPORTUNISTICALLY_MATCH_AUTH_SET_PER_KM,
     FW_GLOBAL_CONFIG_IPSEC_TRANSPORT_REMOTE_MACHINE_AUTHORIZATION_LIST,
     FW_GLOBAL_CONFIG_IPSEC_TRANSPORT_REMOTE_USER_AUTHORIZATION_LIST,
     FW_GLOBAL_CONFIG_ENABLE_PACKET_QUEUE,
     FW_GLOBAL_CONFIG_MAX
 } FW_GLOBAL_CONFIG;
 typedef enum _FW_CONFIG_FLAGS
 {
     FW_CONFIG_FLAG_RETURN_DEFAULT_IF_NOT_FOUND  = 0x0001
 } FW_CONFIG_FLAGS;
 typedef struct tag_FW_NETWORK
 {
    [string, unique]
    wchar_t* pszName;
    FW_PROFILE_TYPE ProfileType;
 } FW_NETWORK, *PFW_NETWORK;
 typedef struct tag_FW_ADAPTER
 {
    [string, unique]
    wchar_t* pszFriendlyName;
    GUID Guid;
 } FW_ADAPTER, *PFW_ADAPTER;
 typedef struct tag_FW_DIAG_APP
 {
    [string, unique]
    wchar_t* pszAppPath;
 } FW_DIAG_APP, *PFW_DIAG_APP;
 typedef
 [v1_enum]
 enum tag_FW_RULE_CATEGORY
 {
    FW_RULE_CATEGORY_BOOT,
    FW_RULE_CATEGORY_STEALTH,
    FW_RULE_CATEGORY_FIREWALL,
    FW_RULE_CATEGORY_CONSEC,
    FW_RULE_CATEGORY_MAX
 } FW_RULE_CATEGORY, *PFW_RULE_CATEGORY;
 typedef struct tag_FW_PRODUCT
 {
    DWORD dwFlags;
    DWORD dwNumRuleCategories;
    [size_is(dwNumRuleCategories), unique]
    FW_RULE_CATEGORY* pRuleCategories;
    [string, ref]
    wchar_t* pszDisplayName;
    [string, unique]
    wchar_t* pszPathToSignedProductExe;
 } FW_PRODUCT, *PFW_PRODUCT;
 typedef enum _tag_FW_IP_VERSION
 {
     FW_IP_VERSION_INVALID,
     FW_IP_VERSION_V4,
     FW_IP_VERSION_V6,
     FW_IP_VERSION_MAX
 }FW_IP_VERSION;
 typedef enum _tag_FW_IPSEC_PHASE
 {
     FW_IPSEC_PHASE_INVALID,
     FW_IPSEC_PHASE_1,
     FW_IPSEC_PHASE_2,
     FW_IPSEC_PHASE_MAX
 }FW_IPSEC_PHASE;
 typedef enum _tag_FW_CS_RULE_FLAGS
 {
     FW_CS_RULE_FLAGS_NONE                        = 0x00,
     FW_CS_RULE_FLAGS_ACTIVE                      = 0x01,
     FW_CS_RULE_FLAGS_DTM                         = 0x02,
     FW_CS_RULE_FLAGS_TUNNEL_BYPASS_IF_ENCRYPTED  = 0x08,
     FW_CS_RULE_FLAGS_OUTBOUND_CLEAR              = 0x10,
     FW_CS_RULE_FLAGS_APPLY_AUTHZ                 = 0x20,
     FW_CS_RULE_FLAGS_KEY_MANAGER_ALLOW_DICTATE_KEY = 0x40,
     FW_CS_RULE_FLAGS_KEY_MANAGER_ALLOW_NOTIFY_KEY = 0x80,
     FW_CS_RULE_FLAGS_SECURITY_REALM              = 0x100,
     FW_CS_RULE_FLAGS_MAX                         = 0x200,
     FW_CS_RULE_FLAGS_MAX_V2_1                    = 0x02,
     FW_CS_RULE_FLAGS_MAX_V2_8                    = 0x04,
     FW_CS_RULE_FLAGS_MAX_V2_10                   = 0x40,
     FW_CS_RULE_FLAGS_MAX_V2_20                   = 0x100
 }FW_CS_RULE_FLAGS;
 typedef enum _tag_FW_CS_RULE_ACTION
 {
     FW_CS_RULE_ACTION_INVALID,
     FW_CS_RULE_ACTION_SECURE_SERVER,
     FW_CS_RULE_ACTION_BOUNDARY,
     FW_CS_RULE_ACTION_SECURE,
     FW_CS_RULE_ACTION_DO_NOT_SECURE,
     FW_CS_RULE_ACTION_MAX
 }FW_CS_RULE_ACTION;
 typedef struct _tag_FW_CS_RULE2_0
 {
     struct _tag_FW_CS_RULE2_0 *pNext;
     WORD                wSchemaVersion;
     [string, range(1,512), ref]
     WCHAR*              wszRuleId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     DWORD               dwProfiles;
     FW_ADDRESSES        Endpoint1;
     FW_ADDRESSES        Endpoint2;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     DWORD               dwLocalTunnelEndpointV4;
     BYTE                LocalTunnelEndpointV6[16];
     DWORD               dwRemoteTunnelEndpointV4;
     BYTE                RemoteTunnelEndpointV6[16];
     FW_PORTS            Endpoint1Ports;
     FW_PORTS            Endpoint2Ports;
     [range(0,256)]
     WORD                wIpProtocol;
     [string, range(1,255)]
     WCHAR*              wszPhase1AuthSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2CryptoSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2AuthSet;
     [range(FW_CS_RULE_ACTION_SECURE_SERVER, FW_CS_RULE_ACTION_MAX)]
     FW_CS_RULE_ACTION   Action;
     WORD                wFlags;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
 }FW_CS_RULE2_0, *PFW_CS_RULE2_0;
 typedef enum _tag_FW_KEY_MODULE_
 {
     FW_KEY_MODULE_DEFAULT = 0x0,
     FW_KEY_MODULE_IKEv1 = 0x1,
     FW_KEY_MODULE_AUTHIP = 0x2,
     FW_KEY_MODULE_IKEv2 = 0x4,
     FW_KEY_MODULE_MAX = 0x8
 } FW_KEY_MODULE;
 typedef struct _tag_FW_CS_RULE2_10
 {
     struct _tag_FW_CS_RULE2_10 *pNext;
     WORD                wSchemaVersion;
     [string, range(1,512), ref]
     WCHAR*              wszRuleId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     DWORD               dwProfiles;
     FW_ADDRESSES        Endpoint1;
     FW_ADDRESSES        Endpoint2;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     DWORD               dwLocalTunnelEndpointV4;
     BYTE                LocalTunnelEndpointV6[16];
     DWORD               dwRemoteTunnelEndpointV4;
     BYTE                RemoteTunnelEndpointV6[16];
     FW_PORTS            Endpoint1Ports;
     FW_PORTS            Endpoint2Ports;
     [range(0,256)]
     WORD                wIpProtocol;
     [string, range(1,255)]
     WCHAR*              wszPhase1AuthSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2CryptoSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2AuthSet;
     [range(FW_CS_RULE_ACTION_SECURE_SERVER, FW_CS_RULE_ACTION_MAX)]
     FW_CS_RULE_ACTION   Action;
     WORD                wFlags;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     [string, range(1,512)]
     WCHAR*              wszMMParentRuleId;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
 }FW_CS_RULE2_10, *PFW_CS_RULE2_10;
 typedef struct _tag_FW_CS_RULE
 {
     struct _tag_FW_CS_RULE *pNext;
     WORD                wSchemaVersion;
     [string, range(1,512), ref]
     WCHAR*              wszRuleId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     DWORD               dwProfiles;
     FW_ADDRESSES        Endpoint1;
     FW_ADDRESSES        Endpoint2;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;
     DWORD               dwLocalTunnelEndpointV4;
     BYTE                LocalTunnelEndpointV6[16];
     DWORD               dwRemoteTunnelEndpointV4;
     BYTE                RemoteTunnelEndpointV6[16];
     FW_PORTS            Endpoint1Ports;
     FW_PORTS            Endpoint2Ports;
     [range(0,256)]
     WORD                wIpProtocol;
     [string, range(1,255)]
     WCHAR*              wszPhase1AuthSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2CryptoSet;
     [string, range(1,255)]
     WCHAR*              wszPhase2AuthSet;
     [range(FW_CS_RULE_ACTION_SECURE_SERVER, FW_CS_RULE_ACTION_MAX)]
     FW_CS_RULE_ACTION   Action;
     WORD                wFlags;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     [string, range(1,512)]
     WCHAR*              wszMMParentRuleId;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
     [string, range(1,512)]
     WCHAR*              wszRemoteTunnelEndpointFqdn;
     FW_ADDRESSES        RemoteTunnelEndpoints;
     DWORD               dwKeyModules;
     DWORD               FwdPathSALifetime;
     [string, range(1,10001)]
     LPWSTR               wszTransportMachineAuthzSDDL;
     [string, range(1,10001)]
     LPWSTR               wszTransportUserAuthzSDDL;
 }FW_CS_RULE, *PFW_CS_RULE;
 typedef enum _tag_FW_AUTH_METHOD
 {
     FW_AUTH_METHOD_INVALID,
     FW_AUTH_METHOD_ANONYMOUS,
     FW_AUTH_METHOD_MACHINE_KERB,
     FW_AUTH_METHOD_MACHINE_SHKEY,
     FW_AUTH_METHOD_MACHINE_NTLM,
     FW_AUTH_METHOD_MACHINE_CERT,
     FW_AUTH_METHOD_USER_KERB,
     FW_AUTH_METHOD_USER_CERT,
     FW_AUTH_METHOD_USER_NTLM,
     FW_AUTH_METHOD_MACHINE_RESERVED,
     FW_AUTH_METHOD_USER_RESERVED,
     FW_AUTH_METHOD_MAX,
     FW_AUTH_METHOD_MAX_2_10 = (FW_AUTH_METHOD_USER_NTLM + 1)
 }FW_AUTH_METHOD;
 typedef enum _tag_FW_AUTH_SUITE_FLAGS
 {
     FW_AUTH_SUITE_FLAGS_NONE                                = 0x0000,
     FW_AUTH_SUITE_FLAGS_CERT_EXCLUDE_CA_NAME                = 0x0001,
     FW_AUTH_SUITE_FLAGS_HEALTH_CERT                         = 0x0002,
     FW_AUTH_SUITE_FLAGS_PERFORM_CERT_ACCOUNT_MAPPING        = 0x0004,
     FW_AUTH_SUITE_FLAGS_CERT_SIGNING_ECDSA256               = 0x0008,
     FW_AUTH_SUITE_FLAGS_CERT_SIGNING_ECDSA384               = 0x0010,
     FW_AUTH_SUITE_FLAGS_MAX_V2_1                            = 0x0020,
     FW_AUTH_SUITE_FLAGS_INTERMEDIATE_CA                     = 0x0020,
     FW_AUTH_SUITE_FLAGS_MAX_V2_10                           = 0x0040,
     FW_AUTH_SUITE_FLAGS_ALLOW_PROXY                         = 0x0040,
     FW_AUTH_SUITE_FLAGS_MAX                                 = 0x0080
 }FW_AUTH_SUITE_FLAGS;
 typedef struct _tag_FW_AUTH_SUITE2_10
 {
     [range(FW_AUTH_METHOD_INVALID+1, FW_AUTH_METHOD_MAX)]
     FW_AUTH_METHOD     Method;
     WORD               wFlags;
     [switch_type(FW_AUTH_METHOD), switch_is(Method)]
     union
     {
         [case(FW_AUTH_METHOD_MACHINE_CERT,FW_AUTH_METHOD_USER_CERT)]
         struct
         {
             [ref, string]
             WCHAR*      wszCAName;
         };
         [case(FW_AUTH_METHOD_MACHINE_SHKEY)]
         struct
         {
             [ref, string]
             WCHAR*          wszSHKey;
         };
         [default]
         ;
     };
 }FW_AUTH_SUITE2_10, *PFW_AUTH_SUITE2_10;
 typedef enum _tag_FW_CERT_CRITERIA_NAME_TYPE
 {
     FW_CERT_CRITERIA_NAME_NONE,
     FW_CERT_CRITERIA_NAME_DNS,
     FW_CERT_CRITERIA_NAME_UPN,
     FW_CERT_CRITERIA_NAME_RFC822,
     FW_CERT_CRITERIA_NAME_CN,
     FW_CERT_CRITERIA_NAME_OU,
     FW_CERT_CRITERIA_NAME_O,
     FW_CERT_CRITERIA_NAME_DC,
     FW_CERT_CRITERIA_NAME_MAX
 }FW_CERT_CRITERIA_NAME_TYPE;
 typedef enum _tag_FW_CERT_CRITERIA_TYPE
 {
     FW_CERT_CRITERIA_TYPE_BOTH,
     FW_CERT_CRITERIA_TYPE_SELECTION,
     FW_CERT_CRITERIA_TYPE_VALIDATION,
     FW_CERT_CRITERIA_TYPE_MAX
 }FW_CERT_CRITERIA_TYPE;
 typedef enum _tag_FW_CERT_CRITERIA_FLAGS
 {
     FW_AUTH_CERT_CRITERIA_FLAGS_NONE            = 0x0000,
     FW_AUTH_CERT_CRITERIA_FLAGS_FOLLOW_RENEWAL  = 0x0001,
     FW_AUTH_CERT_CRITERIA_FLAGS_MAX             = 0x0002
 }FW_AUTH_CERT_CRITERIA_FLAGS;
 typedef struct _tag_FW_CERT_CRITERIA
 {
     WORD wSchemaVersion;
     WORD wFlags;
     FW_CERT_CRITERIA_TYPE CertCriteriaType;
     FW_CERT_CRITERIA_NAME_TYPE NameType;
     [string, unique]
     LPWSTR wszName;
     DWORD dwNumEku;
     [size_is(dwNumEku), unique]
     LPSTR* ppEku;
     [string, unique]
     LPWSTR wszHash;
 }FW_CERT_CRITERIA, *PFW_CERT_CRITERIA;
 typedef struct _tag_FW_AUTH_SUITE
 {
     [range(FW_AUTH_METHOD_INVALID+1, FW_AUTH_METHOD_MAX)]
     FW_AUTH_METHOD     Method;
     WORD               wFlags;
     [switch_type(FW_AUTH_METHOD), switch_is(Method)]
     union
     {
         [case(FW_AUTH_METHOD_MACHINE_CERT,FW_AUTH_METHOD_USER_CERT)]
         struct
         {
             [ref, string]
             WCHAR*    wszCAName;
             [unique]
             PFW_CERT_CRITERIA pCertCriteria;
         };
         [case(FW_AUTH_METHOD_MACHINE_SHKEY)]
         struct
         {
             [ref, string]
             WCHAR*   wszSHKey;
         };
         [case(FW_AUTH_METHOD_MACHINE_KERB, FW_AUTH_METHOD_USER_KERB)]
         struct
         {
             [unique, string]
             WCHAR*   wszProxyServer;
         };
         [default]
         ;
     };
 }FW_AUTH_SUITE, *PFW_AUTH_SUITE;
 typedef enum _tag_FW_AUTH_SET_FLAGS
 {
     FW_AUTH_SET_FLAGS_NONE  = 0x00,
     FW_AUTH_SET_FLAGS_MAX   = 0x01,
 } FW_AUTH_SET_FLAGS;
 typedef struct _tag_FW_AUTH_SET2_10
 {
     struct _tag_FW_AUTH_SET2_10*    pNext;
     WORD                wSchemaVersion;
     [range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)]
     FW_IPSEC_PHASE      IpSecPhase;
     [string, range(1,255), ref]
     WCHAR*              wszSetId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     [range(0, 10000)]
     DWORD               dwNumSuites;
     [size_is(dwNumSuites)]
     PFW_AUTH_SUITE2_10      pSuites;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     DWORD               dwAuthSetFlags;
 }FW_AUTH_SET2_10, *PFW_AUTH_SET2_10;
 typedef struct _tag_FW_AUTH_SET
 {
     struct _tag_FW_AUTH_SET*    pNext;
     WORD                wSchemaVersion;
     [range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)]
     FW_IPSEC_PHASE      IpSecPhase;
     [string, range(1,255), ref]
     WCHAR*              wszSetId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     [range(0, 10000)]
     DWORD               dwNumSuites;
     [size_is(dwNumSuites)]
     PFW_AUTH_SUITE      pSuites;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     DWORD               dwAuthSetFlags;
 }FW_AUTH_SET, *PFW_AUTH_SET;
 typedef enum _tag_FW_CRYPTO_KEY_EXCHANGE_TYPE
 {
     FW_CRYPTO_KEY_EXCHANGE_NONE = 0,
     FW_CRYPTO_KEY_EXCHANGE_DH1,
     FW_CRYPTO_KEY_EXCHANGE_DH2,
     FW_CRYPTO_KEY_EXCHANGE_ECDH256,
     FW_CRYPTO_KEY_EXCHANGE_ECDH384,
     FW_CRYPTO_KEY_EXCHANGE_DH2048,
     FW_CRYPTO_KEY_EXCHANGE_DH24,
     FW_CRYPTO_KEY_EXCHANGE_MAX,
     FW_CRYPTO_KEY_EXCHANGE_DH14 = FW_CRYPTO_KEY_EXCHANGE_DH2048,
     FW_CRYPTO_KEY_EXCHANGE_MAX_V2_10 = FW_CRYPTO_KEY_EXCHANGE_DH24
 }FW_CRYPTO_KEY_EXCHANGE_TYPE;
 typedef enum _tag_FW_CRYPTO_ENCRYPTION_TYPE
 {
     FW_CRYPTO_ENCRYPTION_NONE,
     FW_CRYPTO_ENCRYPTION_DES,
     FW_CRYPTO_ENCRYPTION_3DES,
     FW_CRYPTO_ENCRYPTION_AES128,
     FW_CRYPTO_ENCRYPTION_AES192,
     FW_CRYPTO_ENCRYPTION_AES256,
     FW_CRYPTO_ENCRYPTION_AES_GCM128,
     FW_CRYPTO_ENCRYPTION_AES_GCM192,
     FW_CRYPTO_ENCRYPTION_AES_GCM256,
     FW_CRYPTO_ENCRYPTION_MAX,
     FW_CRYPTO_ENCRYPTION_MAX_V2_0 = FW_CRYPTO_ENCRYPTION_AES_GCM128
 }FW_CRYPTO_ENCRYPTION_TYPE;
 typedef enum _tag_FW_CRYPTO_HASH_TYPE
 {
     FW_CRYPTO_HASH_NONE,
     FW_CRYPTO_HASH_MD5,
     FW_CRYPTO_HASH_SHA1,
     FW_CRYPTO_HASH_SHA256,
     FW_CRYPTO_HASH_SHA384,
     FW_CRYPTO_HASH_AES_GMAC128,
     FW_CRYPTO_HASH_AES_GMAC192,
     FW_CRYPTO_HASH_AES_GMAC256,
     FW_CRYPTO_HASH_MAX,
     FW_CRYPTO_HASH_MAX_V2_0 = FW_CRYPTO_HASH_SHA256
 }FW_CRYPTO_HASH_TYPE;
 typedef enum _tag_FW_CRYPTO_PROTOCOL_TYPE
 {
     FW_CRYPTO_PROTOCOL_INVALID,
     FW_CRYPTO_PROTOCOL_AH,
     FW_CRYPTO_PROTOCOL_ESP,
     FW_CRYPTO_PROTOCOL_BOTH,
     FW_CRYPTO_PROTOCOL_AUTH_NO_ENCAP,
     FW_CRYPTO_PROTOCOL_MAX,
     FW_CRYPTO_PROTOCOL_MAX_2_1 = (FW_CRYPTO_PROTOCOL_BOTH + 1)
 }FW_CRYPTO_PROTOCOL_TYPE;
 typedef enum _tag_FW_CRYPTO_SET_FLAGS
 {
     FW_CRYPTO_SET_FLAGS_NONE     = 0x00,
     FW_CRYPTO_SET_FLAGS_MAX      = 0x01,
 } FW_CRYPTO_SET_FLAGS;
 typedef struct _tag_FW_PHASE1_CRYPTO_SUITE
 {
     [range(FW_CRYPTO_KEY_EXCHANGE_NONE, FW_CRYPTO_KEY_EXCHANGE_MAX-1)]
     FW_CRYPTO_KEY_EXCHANGE_TYPE KeyExchange;
     [range(FW_CRYPTO_ENCRYPTION_NONE+1, FW_CRYPTO_ENCRYPTION_MAX-1)]
     FW_CRYPTO_ENCRYPTION_TYPE   Encryption;
     [range(FW_CRYPTO_HASH_NONE+1, FW_CRYPTO_HASH_MAX-1)]
     FW_CRYPTO_HASH_TYPE         Hash;
     DWORD                       dwP1CryptoSuiteFlags;
 }FW_PHASE1_CRYPTO_SUITE, *PFW_PHASE1_CRYPTO_SUITE;
 typedef struct _tag_FW_PHASE2_CRYPTO_SUITE
 {
     [range(FW_CRYPTO_PROTOCOL_INVALID+1, FW_CRYPTO_PROTOCOL_MAX-1)]
     FW_CRYPTO_PROTOCOL_TYPE    Protocol;
     FW_CRYPTO_HASH_TYPE        AhHash;
     FW_CRYPTO_HASH_TYPE        EspHash;
     FW_CRYPTO_ENCRYPTION_TYPE  Encryption;
     DWORD                      dwTimeoutMinutes;
     DWORD                      dwTimeoutKBytes;
     DWORD                      dwP2CryptoSuiteFlags;
 }FW_PHASE2_CRYPTO_SUITE, *PFW_PHASE2_CRYPTO_SUITE;
 typedef enum _tag_FW_PHASE1_CRYPTO_FLAGS
 {
     FW_PHASE1_CRYPTO_FLAGS_NONE            = 0x00,
     FW_PHASE1_CRYPTO_FLAGS_DO_NOT_SKIP_DH  = 0x01,
     FW_PHASE1_CRYPTO_FLAGS_MAX             = 0x02
 }FW_PHASE1_CRYPTO_FLAGS;
 typedef enum _tag_FW_PHASE2_CRYPTO_PFS
 {
     FW_PHASE2_CRYPTO_PFS_INVALID,
     FW_PHASE2_CRYPTO_PFS_DISABLE,
     FW_PHASE2_CRYPTO_PFS_PHASE1,
     FW_PHASE2_CRYPTO_PFS_DH1,
     FW_PHASE2_CRYPTO_PFS_DH2,
     FW_PHASE2_CRYPTO_PFS_DH2048,
     FW_PHASE2_CRYPTO_PFS_ECDH256,
     FW_PHASE2_CRYPTO_PFS_ECDH384,
     FW_PHASE2_CRYPTO_PFS_DH24,
     FW_PHASE2_CRYPTO_PFS_MAX,
     FW_PHASE2_CRYPTO_PFS_MAX_V2_10 = FW_PHASE2_CRYPTO_PFS_DH24
 }FW_PHASE2_CRYPTO_PFS;
 typedef struct _tag_FW_CRYPTO_SET
 {
     struct _tag_FW_CRYPTO_SET*  pNext;
     WORD                wSchemaVersion;
     [range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)]
     FW_IPSEC_PHASE      IpSecPhase;
     [string, range(1,255), ref]
     WCHAR*              wszSetId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     [switch_type(FW_IPSEC_PHASE), switch_is(IpSecPhase)]
     union
     {
         [case(FW_IPSEC_PHASE_1)]
         struct
         {
             WORD                      wFlags;
             [range(0, 10000)]
             DWORD                     dwNumPhase1Suites;
             [size_is(dwNumPhase1Suites)]
             PFW_PHASE1_CRYPTO_SUITE   pPhase1Suites;
             DWORD                     dwTimeOutMinutes;
             DWORD                     dwTimeOutSessions;
         };
         [case(FW_IPSEC_PHASE_2)]
         struct
         {
             FW_PHASE2_CRYPTO_PFS      Pfs;
             [range(0, 10000)]
             DWORD                     dwNumPhase2Suites;
             [size_is(dwNumPhase2Suites)]
             PFW_PHASE2_CRYPTO_SUITE   pPhase2Suites;
         };
     };
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     DWORD               dwCryptoSetFlags;
 }FW_CRYPTO_SET, *PFW_CRYPTO_SET;
 typedef struct _tag_FW_BYTE_BLOB
 {
     [range(0, 10000)]
     DWORD       dwSize;
     [size_is(dwSize)]
     BYTE*       Blob;
 }FW_BYTE_BLOB, *PFW_BYTE_BLOB;
 typedef struct _tag_FW_COOKIE_PAIR
 {
     UINT64      Initiator;
     UINT64      Responder;
 }FW_COOKIE_PAIR, *PFW_COOKIE_PAIR;
 typedef enum _tag_FW_PHASE1_KEY_MODULE_TYPE
 {
     FW_PHASE1_KEY_MODULE_INVALID,
     FW_PHASE1_KEY_MODULE_IKE,
     FW_PHASE1_KEY_MODULE_AUTH_IP,
     FW_PHASE1_KEY_MODULE_MAX
 }FW_PHASE1_KEY_MODULE_TYPE;
 typedef struct _tag_FW_CERT_INFO
 {
     FW_BYTE_BLOB SubjectName;
     [range(FW_AUTH_SUITE_FLAGS_NONE, FW_AUTH_SUITE_FLAGS_MAX-1)]
     DWORD        dwCertFlags;
 }FW_CERT_INFO, *PFW_CERT_INFO;
 typedef struct _tag_FW_AUTH_INFO
 {
     [range(FW_AUTH_METHOD_INVALID + 1, FW_AUTH_METHOD_MAX)]
     FW_AUTH_METHOD  AuthMethod;
     [switch_type(FW_AUTH_METHOD), switch_is(AuthMethod)]
     union
     {
         [case(FW_AUTH_METHOD_MACHINE_CERT,FW_AUTH_METHOD_USER_CERT)]
         struct
         {
             FW_CERT_INFO        MyCert;
             FW_CERT_INFO        PeerCert;
         };
         [case(FW_AUTH_METHOD_MACHINE_KERB,FW_AUTH_METHOD_USER_KERB,
               FW_AUTH_METHOD_MACHINE_RESERVED,FW_AUTH_METHOD_USER_RESERVED)]
         struct
         {
             [string, range(1,10001)]
             WCHAR*       wszMyId;
             [string, range(1,10001)]
             WCHAR*       wszPeerId;
         };
         [default]
         ;
     };
     DWORD           dwAuthInfoFlags;
 }FW_AUTH_INFO, *PFW_AUTH_INFO;
 typedef struct _tag_FW_ENDPOINTS
 {
     [range(FW_IP_VERSION_INVALID+1, FW_IP_VERSION_MAX-1)]
     FW_IP_VERSION  IpVersion;
     DWORD          dwSourceV4Address;
     DWORD          dwDestinationV4Address;
     BYTE           SourceV6Address[16];
     BYTE           DestinationV6Address[16];
 }FW_ENDPOINTS, *PFW_ENDPOINTS;
 typedef struct _tag_FW_PHASE1_SA_DETAILS
 {
     UINT64                      SaId;
     [range(FW_PHASE1_KEY_MODULE_INVALID+1, FW_PHASE1_KEY_MODULE_MAX-1)]
     FW_PHASE1_KEY_MODULE_TYPE   KeyModuleType;
     FW_ENDPOINTS                Endpoints;
     FW_PHASE1_CRYPTO_SUITE      SelectedProposal;
     DWORD                       dwProposalLifetimeKBytes;
     DWORD                       dwProposalLifetimeMinutes;
     DWORD                       dwProposalMaxNumPhase2;
     FW_COOKIE_PAIR              CookiePair;
     PFW_AUTH_INFO               pFirstAuth;
     PFW_AUTH_INFO               pSecondAuth;
     DWORD                       dwP1SaFlags;
 }FW_PHASE1_SA_DETAILS, *PFW_PHASE1_SA_DETAILS;
 typedef enum _tag_FW_PHASE2_TRAFFIC_TYPE
 {
     FW_PHASE2_TRAFFIC_TYPE_INVALID,
     FW_PHASE2_TRAFFIC_TYPE_TRANSPORT,
     FW_PHASE2_TRAFFIC_TYPE_TUNNEL,
     FW_PHASE2_TRAFFIC_TYPE_MAX
 }FW_PHASE2_TRAFFIC_TYPE;
 typedef struct _tag_FW_PHASE2_SA_DETAILS
 {
     UINT64              SaId;
     [range(FW_DIR_INVALID+1, FW_DIR_MAX-1)]
     FW_DIRECTION        Direction;
     FW_ENDPOINTS        Endpoints;
     WORD                wLocalPort;
     WORD                wRemotePort;
     WORD                wIpProtocol;
     FW_PHASE2_CRYPTO_SUITE  SelectedProposal;
     FW_PHASE2_CRYPTO_PFS    Pfs;
     GUID                TransportFilterId;
     DWORD               dwP2SaFlags;
 }FW_PHASE2_SA_DETAILS, *PFW_PHASE2_SA_DETAILS;
 typedef
     [switch_type(FW_PROFILE_CONFIG)]
 union   _FW_PROFILE_CONFIG_VALUE
 {
     [case(FW_PROFILE_CONFIG_LOG_FILE_PATH)]
     [string, range(1,10001)]
     WCHAR* wszStr;
     [case(FW_PROFILE_CONFIG_DISABLED_INTERFACES)]
     PFW_INTERFACE_LUIDS  pDisabledInterfaces;
     [case(FW_PROFILE_CONFIG_ENABLE_FW,
         FW_PROFILE_CONFIG_DISABLE_STEALTH_MODE,
         FW_PROFILE_CONFIG_SHIELDED,
         FW_PROFILE_CONFIG_DISABLE_UNICAST_RESPONSES_TO_MULTICAST_BROADCAST,
         FW_PROFILE_CONFIG_LOG_DROPPED_PACKETS,
         FW_PROFILE_CONFIG_LOG_SUCCESS_CONNECTIONS,
         FW_PROFILE_CONFIG_LOG_IGNORED_RULES,
         FW_PROFILE_CONFIG_LOG_MAX_FILE_SIZE,
         FW_PROFILE_CONFIG_DISABLE_INBOUND_NOTIFICATIONS,
         FW_PROFILE_CONFIG_AUTH_APPS_ALLOW_USER_PREF_MERGE,
         FW_PROFILE_CONFIG_GLOBAL_PORTS_ALLOW_USER_PREF_MERGE,
         FW_PROFILE_CONFIG_ALLOW_LOCAL_POLICY_MERGE,
         FW_PROFILE_CONFIG_ALLOW_LOCAL_IPSEC_POLICY_MERGE,
         FW_PROFILE_CONFIG_DEFAULT_OUTBOUND_ACTION,
         FW_PROFILE_CONFIG_DEFAULT_INBOUND_ACTION,
         FW_PROFILE_CONFIG_DISABLE_STEALTH_MODE_IPSEC_SECURED_PACKET_EXEMPTION)]
     DWORD*  pdwVal;
 }FW_PROFILE_CONFIG_VALUE, *PFW_PROFILE_CONFIG_VALUE;
 typedef struct _tag_FW_MM_RULE
 {
     struct _tag_FW_MM_RULE *pNext;
     WORD                wSchemaVersion;
     [string, range(1,512), ref]
     WCHAR*              wszRuleId;
     [string, range(1,10001)]
     WCHAR*              wszName;
     [string, range(1,10001)]
     WCHAR*              wszDescription;
     DWORD               dwProfiles;
     FW_ADDRESSES        Endpoint1;
     FW_ADDRESSES        Endpoint2;
     [string, range(1,255)]
     WCHAR*              wszPhase1AuthSet;
     [string, range(1,255)]
     WCHAR*              wszPhase1CryptoSet;
     WORD                wFlags;
     [string, range(1,10001)]
     WCHAR*              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX-1)]
     FW_RULE_ORIGIN_TYPE Origin;
     [string, range(1,10001)]
     WCHAR*              wszGPOName;
     FW_RULE_STATUS      Status;
     DWORD               Reserved;
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
 }FW_MM_RULE, *PFW_MM_RULE;
 typedef enum _tag_FW_MATCH_KEY
 {
     FW_MATCH_KEY_PROFILE,
     FW_MATCH_KEY_STATUS,
     FW_MATCH_KEY_OBJECTID,
     FW_MATCH_KEY_FILTERID,
     FW_MATCH_KEY_APP_PATH,
     FW_MATCH_KEY_PROTOCOL,
     FW_MATCH_KEY_LOCAL_PORT,
     FW_MATCH_KEY_REMOTE_PORT,
     FW_MATCH_KEY_GROUP,
     FW_MATCH_KEY_SVC_NAME,
     FW_MATCH_KEY_DIRECTION,
     FW_MATCH_KEY_LOCAL_USER_OWNER,
     FW_MATCH_KEY_PACKAGE_ID,
     FW_MATCH_KEY_FQBN,
     FW_MATCH_KEY_COMPARTMENT_ID,
 FW_MATCH_KEY_MAX
 }FW_MATCH_KEY;
 typedef enum _tag_FW_DATA_TYPE
 {
     FW_DATA_TYPE_EMPTY,
     FW_DATA_TYPE_UINT8,
     FW_DATA_TYPE_UINT16,
     FW_DATA_TYPE_UINT32,
     FW_DATA_TYPE_UINT64,
     FW_DATA_TYPE_UNICODE_STRING
 }FW_DATA_TYPE;
 typedef struct _tag_FW_MATCH_VALUE
 {
     FW_DATA_TYPE type;
     [switch_type(FW_DATA_TYPE), switch_is(type)]
     union
     {
        [case(FW_DATA_TYPE_UINT8)]
        UINT8 uInt8;
        [case(FW_DATA_TYPE_UINT16)]
        UINT16 uInt16;
        [case(FW_DATA_TYPE_UINT32)]
        UINT32 uInt32;
        [case(FW_DATA_TYPE_UINT64)]
        UINT64 uInt64;
        [case(FW_DATA_TYPE_UNICODE_STRING)]
        struct
        {
            [string, range(1,10001)]
            LPWSTR wszString;
        };
        [case(FW_DATA_TYPE_EMPTY)]
        ;
     };
 }FW_MATCH_VALUE;
 typedef enum _tag_FW_MATCH_TYPE
 {
     FW_MATCH_TYPE_TRAFFIC_MATCH,
     FW_MATCH_TYPE_EQUAL,
     FW_MATCH_TYPE_MAX
 }FW_MATCH_TYPE;
 typedef struct _tag_FW_QUERY_CONDITION
 {
     FW_MATCH_KEY matchKey;
     FW_MATCH_TYPE matchType;
     FW_MATCH_VALUE matchValue;
 }FW_QUERY_CONDITION, *PFW_QUERY_CONDITION;
 typedef struct _tag_FW_QUERY_CONDITIONS
 {
     DWORD dwNumEntries;
     [size_is(dwNumEntries)]
     FW_QUERY_CONDITION *AndedConditions;
 }FW_QUERY_CONDITIONS, *PFW_QUERY_CONDITIONS;
 typedef struct _tag_FW_QUERY
 {
     WORD   wSchemaVersion;
     UINT32 dwNumEntries;
     [size_is(dwNumEntries)]
     FW_QUERY_CONDITIONS *ORConditions;
     FW_RULE_STATUS Status;
 }FW_QUERY, *PFW_QUERY;
 cpp_quote("#endif //__FIREWALL_H_")
 cpp_quote("#define MIDL_user_allocate MIDL_fw_allocate")
 cpp_quote("#define MIDL_user_free MIDL_fw_free")
 cpp_quote("void  * __RPC_USER MIDL_fw_allocate(size_t size);")
 cpp_quote("void __RPC_USER MIDL_fw_free(void  * );")
 [
    uuid(6b5bdd1e-528c-422c-af8c-a4079be4fe48),
    version(1.0),
    pointer_default(unique)
 ]
 interface RemoteFW
 {
 typedef
 handle_t FW_CONN_HANDLE;
 typedef
 [context_handle]
 HANDLE FW_POLICY_STORE_HANDLE;
 typedef
 [ref]
 FW_POLICY_STORE_HANDLE *PFW_POLICY_STORE_HANDLE;
 typedef
 [context_handle]
 void* FW_PRODUCT_HANDLE;
     DWORD
     RRPC_FWOpenPolicyStore(
         [in] FW_CONN_HANDLE                      rpcConnHandle,
         [in] WORD                                BinaryVersion,
         [in, range(FW_STORE_TYPE_INVALID+1, FW_STORE_TYPE_MAX-1)]       FW_STORE_TYPE                       StoreType,
         [in, range(FW_POLICY_ACCESS_RIGHT_INVALID+1, FW_POLICY_ACCESS_RIGHT_MAX-1)]  FW_POLICY_ACCESS_RIGHT AccessRight,
         [in]  DWORD                              dwFlags,
         [out] PFW_POLICY_STORE_HANDLE           phPolicyStore
         );
     DWORD
     RRPC_FWClosePolicyStore(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in, out] PFW_POLICY_STORE_HANDLE  phPolicyStore
         );
     DWORD
     RRPC_FWRestoreDefaults([in] FW_CONN_HANDLE rpcConnHandle);
     DWORD
     RRPC_FWGetGlobalConfig(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] WORD                     BinaryVersion,
         [in] FW_STORE_TYPE            StoreType,
         [in, range(FW_GLOBAL_CONFIG_INVALID+1, FW_GLOBAL_CONFIG_MAX-1)]
           FW_GLOBAL_CONFIG            configID,
         [in] DWORD                    dwFlags,
         [in, out, unique, size_is(cbData), length_is(*pcbTransmittedLen)]
         BYTE*                       pBuffer,
         [in] DWORD                  cbData,
         [in,out]  LPDWORD           pcbTransmittedLen,
         [out] LPDWORD               pcbRequired
         );
    DWORD
    RRPC_FWSetGlobalConfig(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] WORD                       BinaryVersion,
         [in] FW_STORE_TYPE              StoreType,
         [in, range(FW_GLOBAL_CONFIG_INVALID+1, FW_GLOBAL_CONFIG_MAX-1)] FW_GLOBAL_CONFIG              configID,
         [in, unique, size_is(dwBufSize)]
          BYTE *                         lpBuffer,
         [in, range(0, 10*1024)] DWORD dwBufSize
         );
    DWORD
    RRPC_FWAddFirewallRule(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_0             pRule
         );
     DWORD
     RRPC_FWSetFirewallRule(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_0             pRule
         );
     DWORD
     RRPC_FWDeleteFirewallRule(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in, string, ref] LPCWSTR    wszRuleID
         );
     DWORD
     RRPC_FWDeleteAllFirewallRules(
         [in] FW_CONN_HANDLE         rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE hPolicyStore
         );
     DWORD
     RRPC_FWEnumFirewallRules(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD            *pdwNumRules,
         [out] PFW_RULE2_0           *ppRules
         );
     DWORD
     RRPC_FWGetConfig(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in, range(FW_PROFILE_CONFIG_ENABLE_FW, FW_PROFILE_CONFIG_MAX-1)] FW_PROFILE_CONFIG             configID,
         [in] FW_PROFILE_TYPE          Profile,
         [in] DWORD                    dwFlags,
         [in, out, unique, size_is(cbData), length_is(*pcbTransmittedLen)]
         BYTE*                       pBuffer,
         [in] DWORD                  cbData,
         [in,out]  LPDWORD           pcbTransmittedLen,
         [out] LPDWORD               pcbRequired
         );
     DWORD
     RRPC_FWSetConfig(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_PROFILE_CONFIG_ENABLE_FW, FW_PROFILE_CONFIG_MAX-1)] FW_PROFILE_CONFIG              configID,
         [in] FW_PROFILE_TYPE          Profile,
         [in, switch_is(configID)] FW_PROFILE_CONFIG_VALUE  pConfig,
         [in, range(0, 10*1024)] DWORD  dwBufSize
         );
     DWORD
     RRPC_FWAddConnectionSecurityRule(
         [in]  FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE2_0              pRule
         );
     DWORD
     RRPC_FWSetConnectionSecurityRule(
         [in] FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE2_0              pRule
         );
     DWORD
     RRPC_FWDeleteConnectionSecurityRule(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, string, ref] LPWSTR        pRuleId
         );
     DWORD
     RRPC_FWDeleteAllConnectionSecurityRules(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore
         );
     DWORD
     RRPC_FWEnumConnectionSecurityRules(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD *           pdwNumRules,
         [out] PFW_CS_RULE2_0*        ppRules
         );
     DWORD
     RRPC_FWAddAuthenticationSet(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET2_10       pAuth
         );
     DWORD
     RRPC_FWSetAuthenticationSet(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET2_10       pAuth
         );
     DWORD
     RRPC_FWDeleteAuthenticationSet(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE            IpSecPhase,
         [in, string, ref] LPCWSTR      wszSetId
         );
     DWORD
     RRPC_FWDeleteAllAuthenticationSets(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE          IpSecPhase
         );
     DWORD
     RRPC_FWEnumAuthenticationSets(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE            IpSecPhase,
         [in] DWORD                     dwFilteredByStatus,
         [in] WORD                      wFlags,
         [out] DWORD*                   pdwNumAuthSets,
         [out] PFW_AUTH_SET2_10*       ppAuth
         );
     DWORD
     RRPC_FWAddCryptoSet(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_CRYPTO_SET     pCrypto
         );
     DWORD
     RRPC_FWSetCryptoSet(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_CRYPTO_SET          pCrypto
         );
     DWORD
     RRPC_FWDeleteCryptoSet(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE            IpSecPhase,
         [in, string, ref] LPCWSTR      wszSetId
         );
     DWORD
     RRPC_FWDeleteAllCryptoSets(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE          IpSecPhase
         );
     DWORD
     RRPC_FWEnumCryptoSets(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE             IpSecPhase,
         [in] DWORD                      dwFilteredByStatus,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumSets,
         [out] PFW_CRYPTO_SET*      ppCryptoSets
         );
     DWORD
     RRPC_FWEnumPhase1SAs(
         [in] FW_CONN_HANDLE                   rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE           hPolicyStore,
         [in,unique] PFW_ENDPOINTS             pEndpoints,
         [out,ref]  DWORD*                     pdwNumSAs,
         [out,size_is( , *pdwNumSAs)]  PFW_PHASE1_SA_DETAILS*         ppSAs
         );
     DWORD
     RRPC_FWEnumPhase2SAs(
         [in] FW_CONN_HANDLE                   rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE           hPolicyStore,
         [in, unique] PFW_ENDPOINTS            pEndpoints,
         [out,ref]  DWORD*                     pdwNumSAs,
         [out,size_is( , *pdwNumSAs)]  PFW_PHASE2_SA_DETAILS*         ppSAs
         );
     DWORD
     RRPC_FWDeletePhase1SAs(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, unique]PFW_ENDPOINTS       pEndpoints
         );
     DWORD
     RRPC_FWDeletePhase2SAs(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, unique]PFW_ENDPOINTS       pEndpoints
         );
     DWORD
     RRPC_FWEnumProducts(
        [in] FW_CONN_HANDLE rpcConnHandle,
        [in] FW_POLICY_STORE_HANDLE hPolicyStore,
        [out] DWORD* pdwNumProducts,
        [out, size_is(,*pdwNumProducts)] PFW_PRODUCT* ppProducts
        );
     DWORD
     RRPC_FWAddMainModeRule(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_MM_RULE             pMMRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetMainModeRule(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_MM_RULE             pMMRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWDeleteMainModeRule(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, string, ref] LPWSTR       pRuleId
         );
     DWORD
     RRPC_FWDeleteAllMainModeRules(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore
         );
     DWORD
     RRPC_FWEnumMainModeRules(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] DWORD                      dwFilteredByStatus,
         [in] DWORD                      dwProfileFilter,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_MM_RULE  *            ppMMRules
         );
     DWORD
     RRPC_FWQueryFirewallRules(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_RULE2_10  *           ppRules
         );
     DWORD
     RRPC_FWQueryConnectionSecurityRules2_10(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_CS_RULE2_10  *        ppRules
         );
     DWORD
     RRPC_FWQueryMainModeRules(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_MM_RULE  *            ppMMRules
         );
     DWORD
     RRPC_FWQueryAuthenticationSets(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE             IPsecPhase,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumSets,
         [out] PFW_AUTH_SET2_10 *            ppAuthSets
         );
     DWORD
     RRPC_FWQueryCryptoSets(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE             IPsecPhase,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumSets,
         [out] PFW_CRYPTO_SET *          ppCryptoSets
         );
     DWORD
     RRPC_FWEnumNetworks(
        [in] FW_CONN_HANDLE rpcConnHandle,
        [in] FW_POLICY_STORE_HANDLE hPolicyStore,
        [out] DWORD* pdwNumNetworks,
        [out, size_is(,*pdwNumNetworks)] PFW_NETWORK* ppNetworks
        );
     DWORD
     RRPC_FWEnumAdapters(
        [in] FW_CONN_HANDLE rpcConnHandle,
        [in] FW_POLICY_STORE_HANDLE hPolicyStore,
        [out] DWORD* pdwNumAdapters,
        [out, size_is(,*pdwNumAdapters)] PFW_ADAPTER* ppAdapters
        );
     DWORD
     RRPC_FWGetGlobalConfig2_10(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] WORD                     BinaryVersion,
         [in] FW_STORE_TYPE            StoreType,
         [in, range(FW_GLOBAL_CONFIG_INVALID+1, FW_GLOBAL_CONFIG_MAX-1)]
           FW_GLOBAL_CONFIG            configID,
         [in] DWORD                    dwFlags,
         [in, out, unique, size_is(cbData), length_is(*pcbTransmittedLen)]
         BYTE*                       pBuffer,
         [in] DWORD                  cbData,
         [in,out]  LPDWORD           pcbTransmittedLen,
         [out] LPDWORD               pcbRequired,
         [out] FW_RULE_ORIGIN_TYPE * pOrigin
         );
     DWORD
     RRPC_FWGetConfig2_10(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in, range(FW_PROFILE_CONFIG_ENABLE_FW, FW_PROFILE_CONFIG_MAX-1)] FW_PROFILE_CONFIG             configID,
         [in] FW_PROFILE_TYPE          Profile,
         [in] DWORD                    dwFlags,
         [in, out, unique, size_is(cbData), length_is(*pcbTransmittedLen)]
         BYTE*                       pBuffer,
         [in] DWORD                  cbData,
         [in,out]  LPDWORD           pcbTransmittedLen,
         [out] LPDWORD               pcbRequired,
         [out] FW_RULE_ORIGIN_TYPE * pOrigin
         );
    DWORD
    RRPC_FWAddFirewallRule2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_10            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetFirewallRule2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_10            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumFirewallRules2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD            *pdwNumRules,
         [out] PFW_RULE2_10          *ppRules
         );
     DWORD
     RRPC_FWAddConnectionSecurityRule2_10(
         [in] FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE2_10             pRule,
         [out] FW_RULE_STATUS *           pStatus
         );
     DWORD
     RRPC_FWSetConnectionSecurityRule2_10(
         [in] FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE2_10             pRule,
         [out] FW_RULE_STATUS *           pStatus
         );
     DWORD
     RRPC_FWEnumConnectionSecurityRules2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD *           pdwNumRules,
         [out] PFW_CS_RULE2_10*       ppRules
         );
     DWORD
     RRPC_FWAddAuthenticationSet2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET2_10            pAuth,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetAuthenticationSet2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET2_10            pAuth,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumAuthenticationSets2_10(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE            IpSecPhase,
         [in] DWORD                     dwFilteredByStatus,
         [in] WORD                      wFlags,
         [out] DWORD*                   pdwNumAuthSets,
         [out] PFW_AUTH_SET2_10*        ppAuth
         );
     DWORD
     RRPC_FWAddCryptoSet2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_CRYPTO_SET          pCrypto,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetCryptoSet2_10(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_CRYPTO_SET          pCrypto,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumCryptoSets2_10(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE             IpSecPhase,
         [in] DWORD                      dwFilteredByStatus,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumSets,
         [out] PFW_CRYPTO_SET*      ppCryptoSets
         );
     DWORD
     RRPC_FWAddConnectionSecurityRule2_20(
         [in] FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE                 pRule,
         [out] FW_RULE_STATUS *           pStatus
         );
     DWORD
     RRPC_FWSetConnectionSecurityRule2_20(
         [in] FW_CONN_HANDLE              rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE      hPolicyStore,
         [in] PFW_CS_RULE                 pRule,
         [out] FW_RULE_STATUS *           pStatus
         );
     DWORD
     RRPC_FWEnumConnectionSecurityRules2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD *           pdwNumRules,
         [out] PFW_CS_RULE*           ppRules
         );
     DWORD
     RRPC_FWQueryConnectionSecurityRules2_20(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_CS_RULE  *            ppRules
         );
     DWORD
     RRPC_FWAddAuthenticationSet2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET            pAuth,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetAuthenticationSet2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_AUTH_SET            pAuth,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumAuthenticationSets2_20(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE            IpSecPhase,
         [in] DWORD                     dwFilteredByStatus,
         [in] WORD                      wFlags,
         [out] DWORD*                   pdwNumAuthSets,
         [out] PFW_AUTH_SET*       ppAuth
         );
     DWORD
     RRPC_FWQueryAuthenticationSets2_20(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in, range(FW_IPSEC_PHASE_INVALID+1, FW_IPSEC_PHASE_MAX-1)] FW_IPSEC_PHASE             IPsecPhase,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumSets,
         [out] PFW_AUTH_SET*            ppAuthSets
         );
    DWORD
    RRPC_FWAddFirewallRule2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_20            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetFirewallRule2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_20            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumFirewallRules2_20(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD            *pdwNumRules,
         [out] PFW_RULE2_20          *ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_20(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_RULE2_20  *           ppRules
         );
    DWORD
    RRPC_FWAddFirewallRule2_24(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_24            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWSetFirewallRule2_24(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_24            pRule,
         [out] FW_RULE_STATUS *       pStatus
         );
     DWORD
     RRPC_FWEnumFirewallRules2_24(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD            *pdwNumRules,
         [out] PFW_RULE2_24          *ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_24(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_RULE2_24*             ppRules
         );
    DWORD
    RRPC_FWAddFirewallRule2_25(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_25            pRule,
         [out] FW_RULE_STATUS*        pStatus
         );
     DWORD
     RRPC_FWSetFirewallRule2_25(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_25            pRule,
         [out] FW_RULE_STATUS*        pStatus
         );
     DWORD
     RRPC_FWEnumFirewallRules2_25(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD*            pdwNumRules,
         [out] PFW_RULE2_25*          ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_25(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_RULE2_25*             ppRules
         );
    DWORD
    RRPC_FWAddFirewallRule2_26(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_26            pRule,
         [out] FW_RULE_STATUS*        pStatus
         );
     DWORD
     RRPC_FWSetFirewallRule2_26(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] PFW_RULE2_26            pRule,
         [out] FW_RULE_STATUS*        pStatus
         );
     DWORD
     RRPC_FWEnumFirewallRules2_26(
         [in] FW_CONN_HANDLE          rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE  hPolicyStore,
         [in] DWORD                   dwFilteredByStatus,
         [in] DWORD                   dwProfileFilter,
         [in] WORD                    wFlags,
         [out, ref] DWORD            *pdwNumRules,
         [out] PFW_RULE2_26          *ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_26(
         [in] FW_CONN_HANDLE             rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE     hPolicyStore,
         [in] PFW_QUERY                  pQuery,
         [in] WORD                       wFlags,
         [out, ref] DWORD*               pdwNumRules,
         [out] PFW_RULE2_26*             ppRules
         );
     DWORD
     RRPC_FWAddFirewallRule2_27(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE    hPolicyStore,
         [in] PFW_RULE2_27              pRule,
         [out] FW_RULE_STATUS*          pStatus
         );
      DWORD
      RRPC_FWSetFirewallRule2_27(
         [in] FW_CONN_HANDLE            rpcConnHandle,
         [in]  FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in]  PFW_RULE2_27             pRule,
         [out] FW_RULE_STATUS*          pStatus
         );
      DWORD
      RRPC_FWEnumFirewallRules2_27(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in] DWORD                    dwFilteredByStatus,
         [in] DWORD                    dwProfileFilter,
         [in] WORD                     wFlags,
         [out, ref] DWORD*             pdwNumRules,
         [out] PFW_RULE2_27*           ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_27(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in] PFW_QUERY                pQuery,
         [in] WORD                     wFlags,
         [out, ref] DWORD*             pdwNumRules,
         [out] PFW_RULE2_27*           ppRules
         );
     DWORD
     RRPC_FWAddFirewallRule2_31(
         [in]  FW_CONN_HANDLE           rpcConnHandle,
         [in]  FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in]  PFW_RULE                 pRule,
         [out] FW_RULE_STATUS*          pStatus
         );
      DWORD
      RRPC_FWSetFirewallRule2_31(
         [in]  FW_CONN_HANDLE           rpcConnHandle,
         [in]  FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in]  PFW_RULE                 pRule,
         [out] FW_RULE_STATUS*          pStatus
         );
      DWORD
      RRPC_FWEnumFirewallRules2_31(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in] DWORD                    dwFilteredByStatus,
         [in] DWORD                    dwProfileFilter,
         [in] WORD                     wFlags,
         [out, ref] DWORD*             pdwNumRules,
         [out] PFW_RULE*               ppRules
         );
     DWORD
     RRPC_FWQueryFirewallRules2_31(
         [in] FW_CONN_HANDLE           rpcConnHandle,
         [in] FW_POLICY_STORE_HANDLE   hPolicyStore,
         [in] PFW_QUERY                pQuery,
         [in] WORD                     wFlags,
         [out, ref] DWORD*             pdwNumRules,
         [out] PFW_RULE*               ppRules
         );}